import re
text1 = """Классное слово – Обороноспособность,
которое должно идти после слов: трава
и молоко."""
text2 = """  Контекстно-свободная грамматика состоит из множества продукций. В левой части каждой продукции стоит абстрактный символ,
называемый нетерминальным, в правой - последовательность, состоящая из одного или более нетерминальных и терминальных символов.
Для каждой грамматики, терминальные символы - это символы определенного алфавита."""
text3 = """показывает, что ArgumentList может представлять либо просто нетерминал Argument, либо нетерминал ArgumentList,
за которым следует запятая, за которой следует Argument. Данное определение нетерминала ArgumentList рекурсивно, то есть в определении
понятия используется оно же само. В результате нетерминал ArgumentList может содержать любое положительное число нетерминалов Argument."""
text4 = """ Найдите абсолютное отклонение экспериментального значения ускорения свободного падения от его табличного значения
для Санкт-Петербурга. Сравните абсолютную погрешность с разностью между табличным и экспериментальным значениями
Сформулируйте и запишите в отчет вывод о достоверности результатов ваших измерений."""
text5 = """ Достоинством подобного способа выполнения программ является полная независимость байт-кода от операционной системы и
оборудования, что позволяет выполнять Java-приложения на любом устройстве, для которого существует соответствующая виртуальная машина.
Другой важной особенностью технологии Java является гибкая """

spisok = []
words = re.findall(r"[A-zА-я]+",text)

#в этом блоке создается список слов, подходящих по условию
for i in words:    
    letters = (re.findall(r'[АаЕеЁёИиОоУуЫыЭэЮюЯяAaIiEeUuOoYy]',i))
    if (len(letters) == 0):
        continue
    elif (len(letters) == 1):
        spisok.append(i)
    else:
        example = letters[0].lower()
        indicator = True
        for j in letters:
            if (j.lower() != example):
                indicator = False
        if (indicator):
            spisok.append(i)
            
#В этом блоке слова выводятся в нужном порядке
while (len(spisok) != 0):
    min_len = (len(spisok[0])) 
    min_index= spisok[0]
    for i in spisok:
        if len(spisok[spisok.index(i)])<min_len:
            min_len = len(spisok[spisok.index(i)])
            min_index = spisok[spisok.index(i)]
    print(min_index)
    spisok.remove(min_index)
        


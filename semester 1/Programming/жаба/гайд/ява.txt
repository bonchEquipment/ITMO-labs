вместо begin end {  }
 public - идентификатор доступности (доступен для использования в других классов)
private (доступен только для данного класса)
static - переманная всегда одна
final  - не меняется
void - тип возвращения
 метод main должен обязательно существовать
public static void main (String[] args)
{
}
1) доступность
2)идентификатор
3) тип возвращения
4) имя (параметры)  {
          че тут делать то }

-----------------------------------------------------------------------
                                   НАСЛЕДОВАНИЕ
в начале программы public class NAME extends NAMЕ2
значит, в классе NAME доступны все методы из класса  NAME2

Класс, из которого идет наследование  -суперкласс
классы, которые наследуют - подклассы


ПЕРЕЗАПИСЫВАНИЕ - че это такое?
--------------------------------------------------------------------
                             ПРИМЕР СОЗДАНИЯ Ф_ЦИИ
public static void printTextMoreTimes(String s, int count) //ЗАГОЛОВОК МЕТОДА
     {                                                            
   for (int i = 0; i < count; i++)     //ЦИКЛ                      
  public static int cube (int arg) {           //ТЕЛО ЦИКЛА 
return arg*arg*arg; }
}
-----------------------------------------------------------------------------
-логические  1) boolean
 -целочисленные 
1) byte  -128 == 127
2) short -32768 == 32767
3) char       0 65535    все целочисленные (на разные разное кол-во памяти зарезервировано)
4) int   - 20000000000000000000000000== 20000000000000000000
5) long   - сто тыщ миллиардов == сто тыщ миллиардов
- вещественные
1) double 
2) float
почитать  про унарные и бинарные операции
про работу со строками
---------------------------------------------------------------
Formatted output форматированный вывод
doubke x = 5.683
double y = Math.pow(x
printf принимет:
1) String format
2) Object ... args (возможность передать сколько угодно значений)
printf(всегда начинается со знака %)
String b = name.substracting (0 , 4) с 0 символа, вывести 4 
msg - массив строк?
что за оператор new
почитать про массивы
Users\ergre\Documents|NetBeans
----------------------------------------------
9 поинт - это зарезервированное слово, или че тут вообще
10 что значит команда a.x=
10 что значит this.x
object_name.method_name(аргументы, если есть)
10 почему super жирным шрифтом, это какое то зарезервированное 
слово, или че? и что оно делает к this такой же вопрос
11 не особо понял про полиморфизм
че значат ... в java
Интерфейс?
implements?
переопределить его в классе
   
javac компиливует в байт-код (расширение .class)
java [ параметры ] имя_класса [ аргументы ]
компилирует уже в машинный код
если в методе несколько параментров, только последний может быть
с точками
могу написать (String args, String args2) тогда метод примет
максимум ( или обязательно) 2 переменные
если же написать (String ... args), то примет 1 или более
аргументов это будет масив из аргументов)
 даже если это 1 элемент, это все равно будет масив с 1 элементом
pacege - по факту папки, нужны, чтобы  объекты с одним 
именем не были в одной зоне видимости
есть 2 типа данных - примитивный тип (занимает ровно столько, 
сколько ему надо памяти), объектный же тип занимает больше памяти
при битовой операции мы работаем над 1 числом
к чему угодно можно применить toString
int array[]={1,2,3,4,5}
int array[]=new int[10] 
проблема обычного масива - выход за пределы
int[][] a = new int[3][];
дву и трехмерные масивы в яве не обязательно симметричные
(не прямоугольники)
System.arrayCopy() ч это такое?
Название класса с большой, методов и переменных с маленькой
в cmd не работает char + че он вообще делает?
java.util.Scanner;
Scanner myObject = new Scanner (System.in);
тип переменной number;
	 number = myObject.nextInt();
             или
           number = myObject.nextLine();  (string)
                    или 
              number = myObject.nextFloat();
% остаток от деления (mod)
УПРОЩЕНИЯ:
res = res + 45
res += 45
--------------
res -=22
res /=15
res += 1
res++
res--
!=  -не равно
&& лоигческое и
|| логическое или
------------------------------------------------
                      условные операторы 
записываются благодария 
        if (a1 > a2){
        code        } else {
code}
----------------------------------------
с помощью switc case можно проверить переменную на множество значений
          int num = 23;
switch(num) {
 case 12: 
*code*
break ;
 case 444 : 
*code*
 break;
   }
default выполняется, если никакой из кейсов не сработал, в него 
брейк не ставиться
---------------------------------
                  циклы 
              for:
ему нужно 3 параметра (1;2;3)
1- создаешь переменную, присваешь значение
2-условие остановки (i<10) , значит цикл длиться до тех пор,
пока это условие - истина 
3- i++ (за каждый проход цикла)
---------------------------------------------
                while:
int i=0;
while (i<15) {System.out.println("la-la-la") 
  i=i+4
---------------------------------------------
for и while проверяет условие перед выполнением,
do while после
 int a =22
do { code
} while (i>15);
---------------------------
масивы 
int [] name = new int [3];
имя name кол-во переменных 3
индексы идут с 0
arr[0]=23;
arr[2]=454;
System.out.print (arr[2])
можно сделать так:
int [] name = new int [] {1,8,88,1488};
--------------------------------------
многомерные масивы
 int[][] name1 = new int [3][]
теперь каждый елимент 1 масива тоже является масивом,
в первом масиве 3 элимента
можно сделать так - 
int[][] name1 = new int[][]{
 {23,46,15},
 {1,2,44},
 {15,12,12};
}
при обращении указываешь оба индекса
name1[1][1]=234;
System.out.print(name1)     
--------------------------------------
при создании функции в круглыъ скобках указываем, что получает 
ф-ция на вхоже
чтобы вызвать ф-цию:
function_name(параметры);
если мы указали, что ф-ция что то возвращает, то пишем
return object_name;
---------------------------------------
ооп
можно самому создавать тип, создавая класс и обращаясь к нему
pubkic class Class_name {
int amount_of_energy;
float number_of_fingers;

void do_sth (String s1) {
System.out.println(s1);
}
-------------------------------
Class_name a1 = new Class_name() ;2
//теперь могу обращаться к переменным, используя точку
a1.number_of_fingers = 44;
a1. do_sth("textttttt");               
System.out.println(a1.number_of_fingers);
-----------------------------------------------
                конструктор
конструктор создается внутри класса, должен называться также, как
и класс
в одном классе может быть много конструкторов
   public class Noone{
       int height;
       float weight;

    Noone (int a, float b){
this.height = a;
this.weight = b;
}
     Noone (){}
    

}
че делает super?
System.out.printf ("%10.3f", x[i]);
10 -сколько места выделенно под написание числа
3 - сколько чисел после запятой выводится
------------------------------------------------------
привидение типов
int a=0;
long b=15;
a = (int) b;
---------------------------------------------
class Cat {
int claws_lenght;
int age;
}
Cat barsic = new Cat();
barsic.age=15;
barsic instanceof Cat;
} 
как имя клсса то получить, че за view.getClass().getName();
-----------------------------------
Если вдруг пригодиться, то класс Object имеет много крутых штку :
-много что с потоками
-удаляет объекты
-сравнивает классы
-создает клон объекта
-----------------------------
обычно пишешь javac lab0.java
              java lab0
если у тебя в проекте несколько классов (в разных файлов), то суешь их в одну папку 
перед каждым классом пишешь package папка_name
заходишь в cmd в дирекотрию, в которой есть папка, пишешь javac папка_name\lab0.java
                                                           java папка_name\lab0
---------------------------------------------------------------------------------
super - наследуемый конструктор
public Student (int a, int b, int course) {
super (int a, int b);
this.course = course;
}
(если мы создали в главном классе конструктор, который принимает 2 переменные)
если хотим из суперкласса вызвать метод, пишем
super.method_name();
если Student extends Human, то можно написать
Human john = new Student ();
(если в Student есть переопределенные методы, то они беруться оттуда)
---------------------------------------------------------------
"Name: %s \n"  че эти ебаные символы значат, и какие еще есть
при переопределении желательно писать @Override
При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. 
